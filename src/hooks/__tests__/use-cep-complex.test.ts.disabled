import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useCEP, type EnderecoViaCEP } from '../use-cep'

// Mock react-router-dom
const mockNavigate = vi.fn()
vi.mock('react-router-dom', () => ({
  useNavigate: () => mockNavigate
}))

// Mock fetch
const mockFetch = vi.fn()
global.fetch = mockFetch

// Mock environment variable
Object.defineProperty(import.meta, 'env', {
  value: {
    VITE_VIACEP_URL: 'https://viacep.com.br/ws'
  },
  writable: true
})

describe('useCEP - Essential Tests', () => {
  const mockEnderecoValido: EnderecoViaCEP = {
    cep: '01310-200',
    logradouro: 'Avenida Paulista',
    complemento: '',
    bairro: 'Bela Vista',
    localidade: 'São Paulo',
    uf: 'SP',
    ibge: '3550308',
    gia: '1004',
    ddd: '11',
    siafi: '7107'
  }

  beforeEach(() => {
    vi.clearAllMocks()
    mockFetch.mockClear()
  })

  describe('estado inicial', () => {
    it('deve inicializar com estado correto', () => {
      const { result } = renderHook(() => useCEP())

      expect(result.current.endereco).toBeNull()
      expect(result.current.error).toBeNull()
      expect(result.current.isLoading).toBe(false)
      expect(typeof result.current.buscarCEP).toBe('function')
      expect(typeof result.current.clearError).toBe('function')
    })
  })

  describe('validação de CEP', () => {
    it('deve rejeitar CEPs inválidos sem fazer requisição', async () => {
      const { result } = renderHook(() => useCEP())

      await act(async () => {
        await result.current.buscarCEP('123') // CEP muito curto
      })

      expect(result.current.endereco).toBeNull()
      expect(mockFetch).not.toHaveBeenCalled()
    })

    it('deve rejeitar CEPs com todos os dígitos iguais', async () => {
      const { result } = renderHook(() => useCEP())

      await act(async () => {
        await result.current.buscarCEP('11111111')
      })

      expect(result.current.endereco).toBeNull()
      expect(mockFetch).not.toHaveBeenCalled()
    })

    it('deve limpar caracteres não numéricos do CEP', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: () => Promise.resolve(mockEnderecoValido)
      })

      const { result } = renderHook(() => useCEP())

      await act(async () => {
        await result.current.buscarCEP('01.310-200')
      })

      expect(mockFetch).toHaveBeenCalledWith(
        'https://viacep.com.br/ws/01310200/json/',
        expect.objectContaining({
          headers: {
            Accept: 'application/json'
          }
        })
      )
    })
  })

  describe('busca de endereço', () => {
    it('deve buscar endereço com CEP válido', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: () => Promise.resolve(mockEnderecoValido)
      })

      const { result } = renderHook(() => useCEP({ debounceMs: 0, minLoadingTime: 0 }))

      await act(async () => {
        await result.current.buscarCEP('01310200')
      })

      expect(result.current.endereco).toEqual(mockEnderecoValido)
      expect(result.current.error).toBeNull()
      expect(mockFetch).toHaveBeenCalledWith(
        'https://viacep.com.br/ws/01310200/json/',
        expect.objectContaining({
          headers: {
            Accept: 'application/json'
          }
        })
      )
    })

    it('deve tratar CEP não encontrado', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ erro: true })
      })

      const { result } = renderHook(() => useCEP({ debounceMs: 0 })) // Remove debounce para teste

      await act(async () => {
        await result.current.buscarCEP('99999999')
      })

      expect(result.current.endereco).toBeNull()
      expect(result.current.error).toBe('CEP não encontrado. Verifique se o CEP está correto.')
    })

    it('deve tratar erro de rede', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'))

      const { result } = renderHook(() => useCEP({ debounceMs: 0, minLoadingTime: 0 }))

      await act(async () => {
        await result.current.buscarCEP('01310200')
      })

      expect(result.current.endereco).toBeNull()
      expect(result.current.error).toBe('Erro ao buscar endereço. Tente novamente.')
    })
  })

  describe('funcionalidades auxiliares', () => {
    it('deve limpar erro', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Test error'))

      const { result } = renderHook(() => useCEP())

      // Gera um erro
      await act(async () => {
        try {
          await result.current.buscarCEP('01310200')
        } catch {
          // Erro esperado
        }
      })

      expect(result.current.error).toBeTruthy()

      // Limpa o erro
      act(() => {
        result.current.clearError()
      })

      expect(result.current.error).toBeNull()
    })

    it('deve funcionar com diferentes configurações', () => {
      const customConfig = {
        minLoadingTime: 500,
        errorMessage: 'Erro customizado'
      }

      const { result } = renderHook(() => useCEP(customConfig))

      expect(result.current.endereco).toBeNull()
      expect(result.current.error).toBeNull()
      expect(result.current.isLoading).toBe(false)
    })
  })

  describe('interface e contratos', () => {
    it('deve ter todas as propriedades esperadas no retorno', () => {
      const { result } = renderHook(() => useCEP())

      expect(result.current).toHaveProperty('endereco')
      expect(result.current).toHaveProperty('error')
      expect(result.current).toHaveProperty('isLoading')
      expect(result.current).toHaveProperty('buscarCEP')
      expect(result.current).toHaveProperty('clearError')

      expect(typeof result.current.buscarCEP).toBe('function')
      expect(typeof result.current.clearError).toBe('function')
    })

    it('deve manter tipos corretos nos retornos', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: () => Promise.resolve(mockEnderecoValido)
      })

      const { result } = renderHook(() => useCEP({ debounceMs: 0, minLoadingTime: 0 })) // Remove delays para teste

      await act(async () => {
        await result.current.buscarCEP('01310200')
      })

      // Verifica se o endereço foi definido e tem a estrutura esperada
      expect(result.current.endereco).not.toBeNull()
      expect(result.current.endereco).toMatchObject({
        cep: expect.any(String),
        logradouro: expect.any(String),
        bairro: expect.any(String),
        localidade: expect.any(String),
        uf: expect.any(String)
      })
    })
  })
})